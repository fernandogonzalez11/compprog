\documentclass{article}
\usepackage[margin=0.5in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}

% Define colors for syntax highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{cppstyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C++
}

\lstset{style=cppstyle}

\title{}
\author{}
\date{}

\begin{document}
	
	\section*{Template}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		
		// macros
		#define vec vector 
		#define loop(i, a, b) for (int i = a; i < b; i++)
		#define F first
		#define S second
		// constants
		#define INF (1LL << 62)
		#define int long long
		#define printarr(a) cout << #a << ": "; \
		for (auto x : a) cout << x << " "; \
		cout << "\n";
		
		using namespace std;
		
		void solve() {
			
		}
		
		signed main() {
			ios::sync_with_stdio(false);
			cin.tie(0);
			
			int t = 1;
			cin >> t;
			while (t--) solve();
			
			return 0;
		}

	\end{lstlisting}
	
	\section*{Segment Tree Implementation}
	\begin{lstlisting}
		const int N = 1e5;  // limit for array size
		int n;  // array size
		int t[2 * N];
		
		void build() {  // build the tree
			for (int i = n - 1; i > 0; --i) t[i] = t[i<<1] + t[i<<1|1];
		}
		
		void modify(int p, int value) {  // set value at position p
			for (t[p += n] = value; p > 1; p >>= 1) t[p>>1] = t[p] + t[p^1];
		}
		
		int query(int l, int r) {  // sum on interval [l, r)
			int res = 0;
			for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
				if (l&1) res += t[l++];
				if (r&1) res += t[--r];
			}
			return res;
		}
		
		int main() {
			scanf("%d", &n);
			for (int i = 0; i < n; ++i) scanf("%d", t + n + i);
			build();
			modify(0, 1);
			printf("%d\n", query(3, 11));
			return 0;
		}
	\end{lstlisting}
	
	\section*{Trie Implementation}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		using namespace std;
		
		class TrieNode {
			public:
			unordered_map<char, TrieNode*> children;
			bool isEndOfWord;
			
			TrieNode() : isEndOfWord(false) {}
		};
		
		class Trie {
			private:
			TrieNode* root;
			
			public:
			Trie() {
				root = new TrieNode();
			}
			
			void insert(const string& word) {
				TrieNode* current = root;
				for (char ch : word) {
					if (current->children.find(ch) == current->children.end()) {
						current->children[ch] = new TrieNode();
					}
					current = current->children[ch];
				}
				current->isEndOfWord = true;
			}
			
			bool search(const string& word) {
				TrieNode* current = root;
				for (char ch : word) {
					if (current->children.find(ch) == current->children.end()) {
						return false;
					}
					current = current->children[ch];
				}
				return current->isEndOfWord;
			}
			
			bool startsWith(const string& prefix) {
				TrieNode* current = root;
				for (char ch : prefix) {
					if (current->children.find(ch) == current->children.end()) {
						return false;
					}
					current = current->children[ch];
				}
				return true;
			}
		};
	\end{lstlisting}
	
	\section*{Longest Common Subsequence}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		using namespace std;
		
		int longestCommonSubsequence(const string& text1, const string& text2) {
			int m = text1.size(), n = text2.size();
			vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
			
			for (int i = 1; i <= m; ++i) {
				for (int j = 1; j <= n; ++j) {
					if (text1[i - 1] == text2[j - 1]) {
						dp[i][j] = dp[i - 1][j - 1] + 1;
					} else {
						dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
					}
				}
			}
			return dp[m][n];
		}
	\end{lstlisting}
	
	\section*{Longest Increasing Subsequence}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		using namespace std;
		
		int longestIncreasingSubsequence(const vector<int>& nums) {
			vector<int> dp;
			for (int num : nums) {
				auto it = lower_bound(dp.begin(), dp.end(), num);
				if (it == dp.end()) {
					dp.push_back(num);
				} else {
					*it = num;
				}
			}
			return dp.size();
		}
	\end{lstlisting}
	
	\section*{Longest Common Prefix}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		using namespace std;
		
		string longestCommonPrefix(vector<string>& strs) {
			if (strs.empty()) return "";
			
			string prefix = strs[0];
			for (const string& s : strs) {
				while (s.find(prefix) != 0) {
					prefix = prefix.substr(0, prefix.length() - 1);
					if (prefix.empty()) return "";
				}
			}
			return prefix;
		}
	\end{lstlisting}
	
	\section*{Subset Sum Algorithm}
	\begin{lstlisting}
		#include <bits/stdc++.h>
		using namespace std;
		
		bool subsetSum(const vector<int>& nums, int target) {
			int n = nums.size();
			vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));
			
			for (int i = 0; i <= n; ++i) {
				dp[i][0] = true;
			}
			
			for (int i = 1; i <= n; ++i) {
				for (int j = 1; j <= target; ++j) {
					if (nums[i - 1] > j) {
						dp[i][j] = dp[i - 1][j];
					} else {
						dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
					}
				}
			}
			return dp[n][target];
		}
	\end{lstlisting}
	
	\section*{Fenwick Tree}
	\begin{lstlisting}
		int op(int a, int b) {
			return a+b;
		}
		
		int inv(int a) {
			return -a;
		}
		
		const int neu = 0;
		
		struct BIT {
			
			int n;
			vector<int> t;
			
			BIT(int n, vector<int>& a) : n(n), t(n+1, neu) {
				
				for(int i = 1; i <= n; i++) {
					t[i] = op(t[i], a[i-1]);
					int j = i+(i&-i);
					if(j <= n) t[j] = op(t[j], t[i]);
				}
				
			}
			
			void update(int i, int val) {
				
				int curr = range(i, i);
				int x = op(val, inv(curr));
				
				while(i <= n) {
					t[i] = op(t[i], x);
					i += i&-i;
				}
				
			}
			
			int query(int i) {
				
				int ans = neu;
				
				while(i > 0) {
					ans = op(ans, t[i]);
					i -= i&-i;
				}
				
				return ans;
				
			}
			
			int range(int l, int r) {
				
				return op(query(r), inv(query(l-1)));
				
			}
			
		};
	\end{lstlisting}
	
	\section*{Union Find}
	\begin{lstlisting}
		typedef struct uf {
			int *ids, *sizes;
			
			uf(int n) {
				ids = new int[n];
				sizes = new int[n];
				
				for (int i = 0; i < n; i++) {
					ids[i] = i;
					sizes[i] = 1;
				}
			}
			
			int f(int i) {
				int p = i;
				while (ids[p] != p)
				p = ids[p];
				
				while (ids[i] != i) {
					int pp = ids[i];
					ids[i] = p;
					i = pp;
				}
				
				return p;
			}
			
			void u(int i, int j) {
				int p1 = f(i), p2 = f(j);
				if (p1 == p2) return;
				
				int nS = sizes[p1] + sizes[p2];
				
				if (sizes[p1] < sizes[p2]) {
					ids[p1] = p2;
				} else {
					ids[p2] = p1;
				}
				
				sizes[p1] = sizes[p2] = nS;
			}
		} UnionFind;
	\end{lstlisting}
\end{document}